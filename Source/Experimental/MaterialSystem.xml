<?xml version="1.0" encoding="utf-8"?>
<TGL3xMaterial>
  <Samples Structures="
  struct vrec {    
  vec3 ObjectPosition;    
  vec3 ObjectNormal;    
  vec3 ObjectTangent;    
  vec4 WorldPosition;    
  vec3 WorldNormal;    
  vec3 WorldTangent;    
  vec4 WorldCameraPosition;    
  vec3 CameraVector;    
  vec4 ScreenPosition;    
  vec4 VertexColor;    
  vec2 TexCoord0;
  vec2 TexCoord1;
  vec2 TexCoord2;
  vec2 TexCoord3;
  vec2 TexCoord4;
  vec2 TexCoord5;
  vec2 TexCoord6;
  vec2 TexCoord7;  
  };
  
  struct frec {    
  vec3 LightAmbient;    
  vec3 LightDiffuse;    
  vec3 LightSpecular;    
  vec4 WorldPosition;    
  vec3 Emissive;    
  vec3 Diffuse;    
  float DiffusePower;    
  vec3 Specular;    
  float SpecularPower;    
  float Opacity;    
  float OpacityMask;    
  vec3 Normal;    
  vec3 CameraVector; 
  int LightIndex;
  };">
    <Constants>
      <Constants_Scalar ObjectType="VFGCE">
        <overload Const="float" />
        <overload Const="int" />
      </Constants_Scalar>
      <Constants_Vector2 ObjectType="VFGCE">
        <overload Const="vec2" />
      </Constants_Vector2>
      <Constants_Vector3 ObjectType="VFGCE">
        <overload Const="vec3" />
      </Constants_Vector3>
      <Constants_Vector4 ObjectType="VFGCE">
        <overload Const="vec4" />
      </Constants_Vector4>
      <Constants_VertexColor ObjectType="F">
        <overload Version="34" Input="void;" Output="vec4" Global="in vec4 fVertexColor;">{ return ( fVertexColor ); }</overload>
        <overload Version="2" Input="void;" Output="vec4" Global="attribute vec4 fVertexColor;">{ return ( fVertexColor ); }</overload>
      </Constants_VertexColor>
    </Constants>
    <Coordinates>
      <Coordinates_Panner ObjectType="F">
        <overload Input="vec2;float;vec2;" Output="vec2">{ vec2 t = fract(C * B); return ( t + A); }</overload>
        <overload Input="vec2;float;" Output="vec2">{ vec2 t = vec2(fract(B)); return (t + A); }</overload>
      </Coordinates_Panner>
      <Coordinates_Rotator ObjectType="F">
        <overload Input="vec2;float;vec2;float;" Output="vec2">{ vec2 tc = A - C; float t = B * D; t = 6.2831853 * fract(t); vec2 sincos = vec2(sin(t), cos(t)); vec2 rxy = vec2(dot(vec2(sincos.y, -sincos.x), tc), dot(sincos, tc)); rxy += C; return ( rxy ); }</overload>
        <overload Input="vec2;float;" Output="vec2">{ float t = 6.2831853 * fract(B); vec2 sincos = vec2(sin(t), cos(t)); vec2 rxy = vec2(dot(vec2(sincos.y, -sincos.x), A), dot(sincos, A)); return ( rxy ); }</overload>
        <overload Input="vec2;float;vec2;" Output="vec2">{ vec2 tc = A - C; float t = 6.2831853 * fract(B); vec2 sincos = vec2(sin(t), cos(t)); vec2 rxy = vec2(dot(vec2(sincos.y, -sincos.x), tc), dot(sincos, tc)); rxy += C; return ( rxy ); }</overload>
        <overload Input="vec2;float;float;" Output="vec2">{ float t = B * C; t = 6.2831853 * fract(t); vec2 sincos = vec2(sin(t), cos(t)); vec2 rxy = vec2(dot(vec2(sincos.y, -sincos.x), A), dot(sincos, A)); return ( rxy ); }</overload>
      </Coordinates_Rotator>
      <Coordinates_ScreenPosition ObjectType="F">
        <overload Input="void;" Output="vec2" Global="in vec3 fScreenPosition;">{ return fScreenPosition.xy; }</overload>
      </Coordinates_ScreenPosition>
      <Coordinates_TexCoord0 ObjectType="F">
        <overload Version="34" Input="void;" Output="vec2" Global="in vec2 fTexCoord0;">{ return fTexCoord0; }</overload>
      </Coordinates_TexCoord0>
      <Coordinates_TexCoord1 ObjectType="F">
        <overload Version="34" Input="void;" Output="vec2" Global="in vec2 fTexCoord1;">{ return fTexCoord1; }</overload>
      </Coordinates_TexCoord1>
      <Coordinates_TexCoord2 ObjectType="F">
        <overload Version="34" Input="void;" Output="vec2" Global="in vec2 fTexCoord2;">{ return fTexCoord2; }</overload>
      </Coordinates_TexCoord2>
      <Coordinates_TexCoord3 ObjectType="F">
        <overload Version="34" Input="void;" Output="vec2" Global="in vec2 fTexCoord3;">{ return fTexCoord3; }</overload>
      </Coordinates_TexCoord3>
      <Coordinates_TexCoord4 ObjectType="F">
        <overload Version="34" Input="void;" Output="vec2" Global="in vec2 fTexCoord4;">{ return fTexCoord4; }</overload>
      </Coordinates_TexCoord4>
      <Coordinates_TexCoord5 ObjectType="F">
        <overload Version="34" Input="void;" Output="vec2" Global="in vec2 fTexCoord5;">{ return fTexCoord5; }</overload>
      </Coordinates_TexCoord5>
      <Coordinates_TexCoord6 ObjectType="F">
        <overload Version="34" Input="void;" Output="vec2" Global="in vec2 fTexCoord6;">{ return fTexCoord6; }</overload>
      </Coordinates_TexCoord6>
      <Coordinates_TexCoord7 ObjectType="F">
        <overload Version="34" Input="void;" Output="vec2" Global="in vec2 fTexCoord7;">{ return fTexCoord7; }</overload>
      </Coordinates_TexCoord7>
      <Coordinates_ObjectPosition ObjectType="F">
        <overload Version="34" Input="void;" Output="vec3" Global="in vec3 fObjectPosition;">{ return fObjectPosition; }</overload>
        <overload Version="2" Input="void;" Output="vec3" Global="varying vec3 fObjectPosition;">{ return fObjectPosition; }</overload>
      </Coordinates_ObjectPosition>		  
      <Coordinates_WorldPosition ObjectType="F">
        <overload Version="34" Input="void;" Output="vec4" Global="in vec4 fWorldPosition;">{ return fWorldPosition; }</overload>
        <overload Version="2" Input="void;" Output="vec4" Global="varying vec4 fWorldPosition;">{ return fWorldPosition; }</overload>
      </Coordinates_WorldPosition>		  
    </Coordinates>
    <Math>
      <Math_Add ObjectType="VFGCE">
        <overload Input="float;float;" Output="float">{ return A + B; }</overload>
        <overload Input="vec2;vec2;" Output="vec2">{ return A + B; }</overload>
        <overload Input="vec3;vec3;" Output="vec3">{ return A + B; }</overload>
        <overload Input="vec3;vec3;vec3;" Output="vec3">{ return A + B + C; }</overload>
        <overload Input="vec4;vec4;" Output="vec4">{ return A + B; }</overload>
      </Math_Add>
      <Math_Sub ObjectType="VFGCE">
        <overload Input="float;float;" Output="float">{ return A - B; }</overload>
        <overload Input="vec2;vec2;" Output="vec2">{ return A - B; }</overload>
        <overload Input="vec3;vec3;" Output="vec3">{ return A - B; }</overload>
        <overload Input="vec4;vec4;" Output="vec4">{ return A - B; }</overload>
      </Math_Sub>
      <Math_Mul ObjectType="VFGCE">
        <overload Input="float;float;" Output="float">{ return A * B; }</overload>
        <overload Input="vec2;vec2;" Output="vec2">{ return A * B; }</overload>
        <overload Input="vec3;vec3;" Output="vec3">{ return A * B; }</overload>
        <overload Input="vec4;vec4;" Output="vec4">{ return A * B; }</overload>
        <overload Input="vec2;float;" Output="vec2">{ return A * B; }</overload>
        <overload Input="float;vec2;" Output="vec2">{ return B * A; }</overload>
        <overload Input="vec3;float;" Output="vec3">{ return A * B; }</overload>
        <overload Input="float;vec3;" Output="vec3">{ return B * A; }</overload>
        <overload Input="vec4;float;" Output="vec4">{ return A * B; }</overload>
        <overload Input="float;vec4;" Output="vec4">{ return B * A; }</overload>
      </Math_Mul>
      <Math_Div ObjectType="VFGCE">
        <overload Input="float;float;" Output="float">{ return A / B; }</overload>
        <overload Input="vec2;vec2;" Output="vec2">{ return A / B; }</overload>
        <overload Input="vec3;vec3;" Output="vec3">{ return A / B; }</overload>
        <overload Input="vec4;vec4;" Output="vec4">{ return A / B; }</overload>
      </Math_Div>
      <Math_Normalize ObjectType="VFGCE">
        <overload Input="vec3;" Output="vec3">{ return normalize(A); }</overload>
        <overload Input="vec4;" Output="vec4">{ return normalize(A); }</overload>
      </Math_Normalize>
      <Math_DotProduct ObjectType="VFGCE">
        <overload Input="vec2;vec2;" Output="float">{ return dot(A,B); }</overload>
        <overload Input="vec3;vec3;" Output="float">{ return dot(A,B); }</overload>
        <overload Input="vec4;vec4;" Output="float">{ return dot(A,B); }</overload>
      </Math_DotProduct>
      <Math_Power ObjectType="V F G">
        <overload Input="float;float;" Output="float">{ return pow(A,B); }</overload>
        <overload Input="vec2;vec2;" Output="vec2">{ return pow(A,B); }</overload>
        <overload Input="vec3;vec3;" Output="vec3">{ return pow(A,B); }</overload>
        <overload Input="vec4;vec4;" Output="vec4">{ return pow(A,B); }</overload>
      </Math_Power>
      <Math_Sine ObjectType="VFGCE">
        <overload Input="float;" Output="float">{ return sin(A); }</overload>
        <overload Input="vec2;" Output="vec2">{ return sin(A); }</overload>
        <overload Input="vec3;" Output="vec3">{ return sin(A); }</overload>
        <overload Input="vec4;" Output="vec4">{ return sin(A); }</overload>
        <overload Input="float;float;" Output="float">{ return sin(A*B); }</overload>
        <overload Input="vec2;float;" Output="vec2">{ return sin(A*B); }</overload>
        <overload Input="vec3;float;" Output="vec3">{ return sin(A*B); }</overload>
        <overload Input="vec4;float;" Output="vec4">{ return sin(A*B); }</overload>
      </Math_Sine>
      <Math_Cosine ObjectType="VFGCE">
        <overload Input="float;" Output="float">{ return cos(A); }</overload>
        <overload Input="vec2;" Output="vec2">{ return cos(A); }</overload>
        <overload Input="vec3;" Output="vec3">{ return cos(A); }</overload>
        <overload Input="vec4;" Output="vec4">{ return cos(A); }</overload>
        <overload Input="float;float;" Output="float">{ return cos(A*B); }</overload>
        <overload Input="vec2;float;" Output="vec2">{ return cos(A*B); }</overload>
        <overload Input="vec3;float;" Output="vec3">{ return cos(A*B); }</overload>
        <overload Input="vec4;float;" Output="vec4">{ return cos(A*B); }</overload>
      </Math_Cosine>
      <Math_Floor ObjectType="VFGCE">
        <overload Input="float;" Output="float">{ return floor(A); }</overload>
        <overload Input="vec2;" Output="vec2">{ return floor(A); }</overload>
        <overload Input="vec3;" Output="vec3">{ return floor(A); }</overload>
        <overload Input="vec4;" Output="vec4">{ return floor(A); }</overload>
      </Math_Floor>
      <Math_Abs ObjectType="VFGCE">
        <overload Input="float;" Output="float">{ return abs(A); }</overload>
        <overload Input="vec2;" Output="vec2">{ return abs(A); }</overload>
        <overload Input="vec3;" Output="vec3">{ return abs(A); }</overload>
        <overload Input="vec4;" Output="vec4">{ return abs(A); }</overload>
      </Math_Abs>
      <Math_Fract ObjectType="VFGCE">
        <overload Input="float;" Output="float">{ return fract(A); }</overload>
        <overload Input="vec2;" Output="vec2">{ return fract(A); }</overload>
        <overload Input="vec3;" Output="vec3">{ return fract(A); }</overload>
        <overload Input="vec4;" Output="vec4">{ return fract(A); }</overload>
      </Math_Fract>
      <Math_Phong ObjectType="F">
        <overload Input="vec3;vec3;float;" Output="float">{ return pow(max(dot(A,B),0.0),C); }</overload>
      </Math_Phong>
      <Math_OneMinus ObjectType="VFGCE">
        <overload Input="float;" Output="float">{ return (1.0-A); }</overload>
        <overload Input="vec2;" Output="vec2">{ return (vec2(1.0)-A); }</overload>
        <overload Input="vec3;" Output="vec3">{ return (vec3(1.0)-A); }</overload>
        <overload Input="vec4;" Output="vec4">{ return (vec4(1.0)-A); }</overload>
      </Math_OneMinus>
      <Math_SquareRoot ObjectType="VFGCE">
        <overload Input="float;" Output="float">{ return sqrt(A); }</overload>
        <overload Input="vec2;" Output="vec2">{ return sqrt(A); }</overload>
        <overload Input="vec3;" Output="vec3">{ return sqrt(A); }</overload>
        <overload Input="vec4;" Output="vec4">{ return sqrt(A); }</overload>
      </Math_SquareRoot>
      <Math_Sign ObjectType="VFGCE">
        <overload Input="float;" Output="float">{ return sign(A); }</overload>
        <overload Input="vec2;" Output="vec2">{ return sign(A); }</overload>
        <overload Input="vec3;" Output="vec3">{ return sign(A); }</overload>
        <overload Input="vec4;" Output="vec4">{ return sign(A); }</overload>
      </Math_Sign>
    </Math>
    <Texture>
      <Texture2D_Sampler0 ObjectType="FGCE">
        <overload Version="34" Input="vec2;" Output="vec4" Uniforms="TShaderEnvSamplers;" Global="uniform sampler2D TexUnit0;">{ return texture(TexUnit0, A); }</overload>
      </Texture2D_Sampler0>
      <Texture2D_Sampler1 ObjectType="FGCE">
        <overload Version="34" Input="vec2;" Output="vec4" Uniforms="TShaderEnvSamplers;" Global="uniform sampler2D TexUnit1;">{ return texture(TexUnit1, A); }</overload>
      </Texture2D_Sampler1>
      <Texture2D_Sampler2 ObjectType="FGCE">
        <overload Version="34" Input="vec2;" Output="vec4" Uniforms="TShaderEnvSamplers;" Global="uniform sampler2D TexUnit2;">{ return texture(TexUnit2, A); }</overload>
      </Texture2D_Sampler2>
      <Texture2D_Sampler3 ObjectType="FGCE">
        <overload Version="34" Input="vec2;" Output="vec4" Uniforms="TShaderEnvSamplers;" Global="uniform sampler2D TexUnit3;">{ return texture(TexUnit3, A); }</overload>
      </Texture2D_Sampler3>
      <Texture2D_Sampler4 ObjectType="FGCE">
        <overload Version="34" Input="vec2;" Output="vec4" Uniforms="TShaderEnvSamplers;" Global="uniform sampler2D TexUnit4;">{ return texture(TexUnit4, A); }</overload>
      </Texture2D_Sampler4>
      <Texture2D_Sampler5 ObjectType="FGCE">
        <overload Version="34" Input="vec2;" Output="vec4" Uniforms="TShaderEnvSamplers;" Global="uniform sampler2D TexUnit5;">{ return texture(TexUnit5, A); }</overload>
      </Texture2D_Sampler5>
      <Texture2D_Sampler6 ObjectType="FGCE">
        <overload Version="34" Input="vec2;" Output="vec4" Uniforms="TShaderEnvSamplers;" Global="uniform sampler2D TexUnit6;">{ return texture(TexUnit6, A); }</overload>
      </Texture2D_Sampler6>
      <Texture2D_Sampler7 ObjectType="FGCE">
        <overload Version="34" Input="vec2;" Output="vec4" Uniforms="TShaderEnvSamplers;" Global="uniform sampler2D TexUnit7;">{ return texture(TexUnit7, A); }</overload>
      </Texture2D_Sampler7>
      <TextureCube_Sampler0 ObjectType="FGCE">
        <overload Version="34" Input="vec3;" Output="vec4" Uniforms="TShaderEnvSamplers;" Global="uniform samplerCube TexUnit0;">{ return texture(TexUnit0, A); }</overload>
      </TextureCube_Sampler0>
      <TextureCube_Sampler1 ObjectType="FGCE">
        <overload Version="34" Input="vec3;" Output="vec4" Uniforms="TShaderEnvSamplers;" Global="uniform samplerCube TexUnit1;">{ return texture(TexUnit1, A); }</overload>
      </TextureCube_Sampler1>
      <TextureCube_Sampler2 ObjectType="FGCE">
        <overload Version="34" Input="vec3;" Output="vec4" Uniforms="TShaderEnvSamplers;" Global="uniform samplerCube TexUnit2;">{ return texture(TexUnit2, A); }</overload>
      </TextureCube_Sampler2>
      <TextureCube_Sampler3 ObjectType="FGCE">
        <overload Version="34" Input="vec3;" Output="vec4" Uniforms="TShaderEnvSamplers;" Global="uniform samplerCube TexUnit3;">{ return texture(TexUnit3, A); }</overload>
      </TextureCube_Sampler3>
      <TextureCube_Sampler4 ObjectType="FGCE">
        <overload Version="34" Input="vec3;" Output="vec4" Uniforms="TShaderEnvSamplers;" Global="uniform samplerCube TexUnit4;">{ return texture(TexUnit4, A); }</overload>
      </TextureCube_Sampler4>
      <TextureCube_Sampler5 ObjectType="FGCE">
        <overload Version="34" Input="vec3;" Output="vec4" Uniforms="TShaderEnvSamplers;" Global="uniform samplerCube TexUnit5;">{ return texture(TexUnit5, A); }</overload>
      </TextureCube_Sampler5>
      <TextureCube_Sampler6 ObjectType="FGCE">
        <overload Version="34" Input="vec3;" Output="vec4" Uniforms="TShaderEnvSamplers;" Global="uniform samplerCube TexUnit6;">{ return texture(TexUnit6, A); }</overload>
      </TextureCube_Sampler6>
      <TextureCube_Sampler7 ObjectType="FGCE">
        <overload Version="34" Input="vec3;" Output="vec4" Uniforms="TShaderEnvSamplers;" Global="uniform samplerCube TexUnit7;">{ return texture(TexUnit7, A); }</overload>
      </TextureCube_Sampler7>
      <SNorm ObjectType="F">
        <overload Version="34" Input="vec4;" Output="vec4" Uniforms="TShaderEnvNormalMatrix;" Global="in vec3 fObjectNormal; in vec3 fObjectTangent; uniform mat3 NormalMatrix;">{ 
  vec3 sN = vec3(2.0)*A.xyz-vec3(1.0);
  vec3 normal = normalize(fObjectNormal);   
  vec3 tangent = normalize(fObjectTangent);
  vec3 binormal = cross(normal,tangent);
  mat3 basis = mat3(tangent,binormal,normal);
  vec3 N;
  N = basis*sN.xyz;
  N = NormalMatrix*N;
  return vec4(N,0.0); 
}</overload>
      </SNorm>
      <SNormDerive ObjectType="F">
        <overload Version="34" Input="vec4;" Output="vec4" Uniforms="TShaderEnvNormalMatrix;" Global="in vec3 fObjectNormal; in vec3 fObjectTangent; uniform mat3 NormalMatrix;">{ 
  vec3 sN = vec3(A.x,A.y,sqrt(1.0-A.x*A.x-A.y*A.y));
  sN = vec3(2.0)*sN-vec3(1.0);
  vec3 normal = normalize(fObjectNormal);   
  vec3 tangent = normalize(fObjectTangent);
  vec3 binormal = cross(normal,tangent);
  mat3 basis = mat3(tangent,binormal,normal);
  vec3 N;
  N = basis*sN.xyz;
  N = NormalMatrix*N;
  return vec4(N,0.0); 
}</overload>
      </SNormDerive>
      <YCoCg ObjectType="F">
        <overload Input="vec4;" Output="vec4">{
  const float offset = 128.0 / 255.0;
  float Y = A.a;
  float scale = 1.0 / ((255.0 / 8.0) * A.b + 1.0);
  float Co = (A.r - offset) * scale;
  float Cg = (A.g - offset) * scale;
  float Red = Y + Co - Cg;
  float Green = Y + Cg;
  float Blue = Y - Co - Cg;
  return vec4(Red, Green, Blue, 1.0);
}</overload>
      </YCoCg>
    </Texture>
    <Utility>
      <Utility_Timer ObjectType="VFGCE">
        <overload Input="void;" Output="float" Uniforms="TShaderEnvTime;" Global="uniform float Time;">{ return Time; }</overload>
      </Utility_Timer>
      <Utility_Clamp ObjectType="VFGCE">
        <overload Input="float;float;float;" Output="float">{ return clamp(A,B,C); }</overload>
        <overload Input="vec2;vec2;vec2;" Output="vec2">{ return clamp(A,B,C); }</overload>
        <overload Input="vec3;vec3;vec3;" Output="vec3">{ return clamp(A,B,C); }</overload>
        <overload Input="vec4;vec4;vec4;" Output="vec4">{ return clamp(A,B,C); }</overload>
      </Utility_Clamp>
      <Utility_ComponentMask ObjectType="VFGCE">
        <overload Mask="True" />
      </Utility_ComponentMask>
      <Utility_Min ObjectType="VFGCE">
        <overload Input="float;float;" Output="float">{ return min(A,B); }</overload>
        <overload Input="vec2;vec2;" Output="vec2">{ return min(A,B); }</overload>
        <overload Input="vec3;vec3;" Output="vec3">{ return min(A,B); }</overload>
        <overload Input="vec4;vec4;" Output="vec4">{ return min(A,B); }</overload>
      </Utility_Min>
      <Utility_Max ObjectType="VFGCE">
        <overload Input="float;float;" Output="float">{ return max(A,B); }</overload>
        <overload Input="vec2;vec2;" Output="vec2">{ return max(A,B); }</overload>
        <overload Input="vec3;vec3;" Output="vec3">{ return max(A,B); }</overload>
        <overload Input="vec4;vec4;" Output="vec4">{ return max(A,B); }</overload>
      </Utility_Max>
      <Utility_BumpOffset ObjectType="F">
        <overload Input="vec2;float;float;float;" Output="vec2" Global="in float fCameraTangentVector;">{ float offset = B*C - D * fCameraTangentVector / C; return A + vec2(offset, offset); }</overload>
      </Utility_BumpOffset>
      <Utility_AppendVector ObjectType="VFGCE">
        <overload Input="float;float;" Output="vec2">{ return vec2(A,B); }</overload>
        <overload Input="float;vec2;" Output="vec3">{ return vec3(A,B); }</overload>
        <overload Input="vec2;float;" Output="vec3">{ return vec3(A,B); }</overload>
        <overload Input="float;vec3;" Output="vec4">{ return vec4(A,B); }</overload>
        <overload Input="vec3;float;" Output="vec4">{ return vec4(A,B); }</overload>
        <overload Input="vec2;vec2;" Output="vec4">{ return vec4(A,B); }</overload>
      </Utility_AppendVector>
    </Utility>
    <Vectors>
      <Vectors_LightVector ObjectType="F">
        <overload Version="34" Input="inout frec;" Output="vec3" Global="struct lrec {
		vec4 WorldPosition;
		vec3 Ambient; 
		vec3 Diffuse; 
		vec3 Specular; 
		vec3 SpotDirection; 
		float SpotCutoff; 
		float SpotExponent; 
		float ConstantAtten; 
		float LinearAtten; 
		float QuadAtten;
        float SpotCosCutoff;
		};
		
		lrec GetLight(int I); ">{     
lrec LightSource = GetLight(A.LightIndex);
if (LightSource.WorldPosition.w == 1.0)
{
  return normalize(LightSource.WorldPosition.xyz - A.WorldPosition.xyz);
}
else
{
  return normalize(LightSource.WorldPosition.xyz);
} 
}</overload>		
      </Vectors_LightVector>
      <Vectors_CameraVector ObjectType="F">
        <overload Input="inout frec;" Output="vec3" >{ return A.CameraVector; }</overload>  
      </Vectors_CameraVector>
      <Vectors_WorldNormal ObjectType="F">
        <overload Version="34" Input="void;" Output="vec3" Global="in vec3 fWorldNormal;">{ return normalize(fWorldNormal); }</overload>
        <overload Version="2" Input="void;" Output="vec3" Global="varying vec3 fWorldNormal;">{ return normalize(fWorldNormal); }</overload>
      </Vectors_WorldNormal>
      <Vectors_ReflectionVector ObjectType="F">
        <overload Input="inout frec;" Output="vec3" >{ return reflect(-A.CameraVector, A.Normal); }</overload>
      </Vectors_ReflectionVector>
    </Vectors>
    <Vertex>
      <GetVertex ObjectType="V">
        <overload Version="34" Input="inout vrec;" Output="void" Global="in vec3 Position; in vec3 Normal; in vec3 Tangent; in vec4 VertexColor; in vec2 TexCoord0; in vec2 TexCoord1; in vec2 TexCoord2; in vec2 TexCoord3; in vec2 TexCoord4; in vec2 TexCoord5; in vec2 TexCoord6; in vec2 TexCoord7;">{
  A.ObjectPosition = Position;
  A.ObjectNormal = Normal;
  A.ObjectTangent = Tangent;
  A.VertexColor = VertexColor;
  A.TexCoord0 = TexCoord0;
  A.TexCoord1 = TexCoord1;
  A.TexCoord2 = TexCoord2;
  A.TexCoord3 = TexCoord3;
  A.TexCoord4 = TexCoord4;
  A.TexCoord5 = TexCoord5;
  A.TexCoord6 = TexCoord6;
  A.TexCoord7 = TexCoord7;
}</overload>
        <overload Version="2" Input="inout vrec;" Output="void" Global="attribute vec3 Position; attribute vec3 Normal; attribute vec3 Tangent; attribute vec4 VertexColor; attribute vec2 TexCoord0; attribute vec2 TexCoord1; attribute vec2 TexCoord2; attribute vec2 TexCoord3; attribute vec2 TexCoord4; attribute vec2 TexCoord5; attribute vec2 TexCoord6; attribute vec2 TexCoord7;">{
  A.ObjectPosition = Position;
  A.ObjectNormal = Normal;
  A.ObjectTangent = Tangent;
  A.VertexColor = VertexColor;
  A.TexCoord0 = TexCoord0;
  A.TexCoord1 = TexCoord1;
  A.TexCoord2 = TexCoord2;
  A.TexCoord3 = TexCoord3;
  A.TexCoord4 = TexCoord4;
  A.TexCoord5 = TexCoord5;
  A.TexCoord6 = TexCoord6;
  A.TexCoord7 = TexCoord7;
}</overload>
      </GetVertex>
      <AtmosphereColor ObjectType="V">
        <overload Version="34" Input="inout vrec;" Output="void" Uniforms="TShaderEnvAtmosphere;" Global="
uniform vec3 spherePosition;
uniform vec3 sunPosition;
uniform vec3 LowAtmColor;
uniform vec3 HighAtmColor;
uniform float invAtmosphereHeight;
uniform float PlanetRadius;
uniform float AtmoRadius;
uniform float AtmoOpacity;" 
		Local="
bool RayCastSphereIntersect(inout vrec A, vec3 rayVector, float sphereRadius, out vec3 i1, out vec3 i2)
{
 float proj = dot(rayVector, spherePosition - A.WorldCameraPosition.xyz);
 vec3 projPoint = rayVector * proj + A.WorldCameraPosition.xyz;
 vec3 range = spherePosition - projPoint;
 float d2 = sphereRadius * sphereRadius - dot(range, range);
 if (d2 &gt;= 0.0)
 {
  d2 = sqrt(d2);
  i1 = rayVector * (proj-d2) + A.WorldCameraPosition.xyz;
  i2 = rayVector * (proj+d2) + A.WorldCameraPosition.xyz;
  return (true);
 }
 else return (false);
}		
void SetAtmosphereColor(inout vrec A, vec3 rayStart, vec3 rayEnd)
{
  A.VertexColor = vec4(0.0);
  float rayLength = distance(rayStart, rayEnd);
  int n = int(3.0 * rayLength * invAtmosphereHeight) + 2;
  if (n &gt; 10) n = 10;
  float contrib = rayLength * AtmoOpacity / float(n);
  float decay = 1.0 - contrib * 0.5;
  contrib *= 1.0/1.1;
  vec3 normal, atmPoint, lightVector;
  lightVector = normalize(sunPosition - A.WorldPosition.xyz);
  for (int I = n-1; I &gt;= 0; I--)
  {
    atmPoint = mix(rayStart, rayEnd, float(I) / float(n)) - spherePosition;
    normal = normalize(atmPoint);
    float intensity = max(dot(normal, lightVector), 0.0) + 0.1;
    if (intensity &gt; 0.0)
    {
      intensity *= contrib;
      float alt = (length(atmPoint) - PlanetRadius) * invAtmosphereHeight;
      vec3 altColor = mix(LowAtmColor, HighAtmColor, alt);
      A.VertexColor.rgb = A.VertexColor.rgb * decay + altColor * intensity;
    }
    else A.VertexColor.rgb *= decay;
  }
  A.VertexColor.a = float(n) * contrib * AtmoOpacity * 0.1;
}"
>{
 vec3 ai1, ai2, pi1, pi2;
 vec3 rayVector = - A.CameraVector;
 if (RayCastSphereIntersect(A, rayVector, AtmoRadius, ai1, ai2))
 {
   A.WorldPosition.xyz = ai1;
   if (RayCastSphereIntersect(A, rayVector, PlanetRadius, pi1, pi2))
   {
      SetAtmosphereColor(A, ai1, pi1);
   }
   else
   {
      SetAtmosphereColor(A, ai1, ai2);
   }
 }
 else { A.VertexColor = vec4(0.0); }
}</overload>
	  </AtmosphereColor>
      <TransformVertex_O2W ObjectType="V">
        <overload Input="inout vrec;" Output="void" Uniforms="TShaderEnvModelMatrix;" Global="uniform mat4 ModelMatrix;">{
  A.WorldPosition = ModelMatrix * vec4(A.ObjectPosition, 1.0);
  A.WorldNormal = mat3(ModelMatrix) * A.ObjectNormal;
  A.WorldTangent = mat3(ModelMatrix) * A.ObjectTangent;
}</overload>
      </TransformVertex_O2W>
      <TransformVertex_W2S ObjectType="V">
        <overload Input="inout vrec;" Output="void" Uniforms="TShaderEnvViewProjectionMatrix;" Global="uniform mat4 ViewProjectionMatrix;">{
  A.ScreenPosition = ViewProjectionMatrix * A.WorldPosition;
}</overload>
      </TransformVertex_W2S>
      <GetCamera ObjectType="V">
        <overload Input="inout vrec;" Output="void" Uniforms="TShaderEnvCameraWorldPosition;" Global="uniform vec4 CameraWorldPosition;">{
  A.WorldCameraPosition = CameraWorldPosition;
  A.CameraVector = (A.WorldCameraPosition - A.WorldPosition).xyz;
  A.CameraVector = normalize(A.CameraVector);
}</overload>
      </GetCamera>
      <PassVertex ObjectType="V">
        <overload Version="34" Input="inout vrec;" Output="void" Global="
		#ifndef GEOMETRY_STAGE  
        out vec3 fObjectPosition;		
		out vec3 fObjectNormal;   
        out vec3 fObjectTangent;		
		out vec4 fWorldPosition;    
		out vec3 fWorldNormal;    
		out vec3 fWorldTangent;    
		out vec4 fVertexColor;    
		out vec3 fCameraVector;    
		#else    
        out vec3 gObjectPosition;		
		out vec3 gObjectNormal;  
        out vec3 gObjectTangent;		
		out vec4 gWorldPosition;   
		out vec3 gWorldNormal;    
		out vec3 gWorldTangent;   
		out vec4 gVertexColor;    
		out vec3 gCameraVector;   
		out vec4 gScreenPosition;   
		#endif">{
#ifndef GEOMETRY_STAGE
  fObjectPosition = A.ObjectPosition;
  fWorldPosition = A.WorldPosition;
  fObjectNormal = A.ObjectNormal;
  fObjectTangent = A.ObjectTangent;  
  gl_Position = A.ScreenPosition;
  fWorldNormal = A.WorldNormal;
  fWorldTangent = A.WorldTangent;
  fVertexColor = A.VertexColor;
  fCameraVector = A.CameraVector;
#else
  gObjectPosition = A.ObjectPosition;
  gObjectNormal = A.ObjectNormal;
  gObjectTangent = A.ObjectTangent; 
  gWorldPosition = A.WorldPosition;  
  gWorldNormal = A.WorldNormal;
  gWorldTangent = A.WorldTangent;
  gVertexColor = A.VertexColor;
  gCameraVector = A.CameraVector;
  gScreenPosition = A.ScreenPosition;
#endif
}</overload>
        <overload Version="2" Input="inout vrec;" Output="void" Global="varying vec3 fObjectNormal; varying vec4 fWorldPosition; varying vec3 fWorldNormal; varying vec4 fVertexColor; varying vec3 fLightVector; varying vec3 fCameraVector;">{
  fWorldPosition = A.WorldPosition;
  gl_Position = A.ScreenPosition;
  fObjectNormal = A.ObjectNormal;
  fWorldNormal = A.WorldNormal;
  fVertexColor = A.VertexColor;
  fLightVector = A.LightVector;
  fCameraVector = A.CameraVector;
}</overload>
      </PassVertex>
      <PassTexCoord0 ObjectType="V">
        <overload Version="34" Input="inout vrec;" Output="void" Global="
		#ifndef GEOMETRY_STAGE     
		out vec2 fTexCoord0;     
		#else     
		out vec2 gTexCoord0;     
		#endif">{
#ifndef GEOMETRY_STAGE
  fTexCoord0 = A.TexCoord0;
#else
  gTexCoord0 = A.TexCoord0;  
#endif
}</overload>
        <overload Version="2" Input="inout vrec;" Output="void" Global="varying vec2 fTexCoord0;">{ fTexCoord0 = A.TexCoord0; }</overload>
        <overload Version="34" Input="inout vrec;vec2;" Output="void" Global="#ifndef GEOMETRY_STAGE     
		out vec2 fTexCoord0;     
		#else     
		out vec2 gTexCoord0;     
		#endif">{
#ifndef GEOMETRY_STAGE
  fTexCoord0 = A.TexCoord0*B;
#else
  gTexCoord0 = A.TexCoord0*B;  
#endif
}</overload>
        <overload Version="2" Input="inout vrec;" Output="void" Global="varying vec2 fTexCoord0">{
  fTexCoord0 = A.TexCoord0*B;
}</overload>
      </PassTexCoord0>
      <PassTexCoord1 ObjectType="V">
        <overload Version="34" Input="inout vrec;" Output="void" Global="#ifndef GEOMETRY_STAGE     
		out vec2 fTexCoord1;     
		#else     
		out vec2 gTexCoord1;     
		#endif">{
#ifndef GEOMETRY_STAGE
  fTexCoord1 = A.TexCoord1;
#else
  gTexCoord1 = A.TexCoord1;  
#endif
}</overload>
        <overload Version="2" Input="inout vrec;" Output="void" Global="varying vec2 fTexCoord1;">{ fTexCoord1 = A.TexCoord1; }</overload>
        <overload Version="34" Input="inout vrec;vec2;" Output="void" Global="#ifndef GEOMETRY_STAGE     
		out vec2 fTexCoord1;     
		#else     
		out vec2 gTexCoord1;     
		#endif">{
#ifndef GEOMETRY_STAGE
  fTexCoord1 = A.TexCoord1*B;
#else
  gTexCoord1 = A.TexCoord1*B;  
#endif
}</overload>
        <overload Version="2" Input="inout vrec;vec2;" Output="void" Global="varying vec2 fTexCoord1;">{ fTexCoord1 = A.TexCoord1*B; }</overload>
      </PassTexCoord1>
      <PassTexCoord2 ObjectType="V">
        <overload Version="34" Input="inout vrec;" Output="void" Global="#ifndef GEOMETRY_STAGE     
		out vec2 fTexCoord2;     
		#else     
		out vec2 gTexCoord2;     
		#endif">{
#ifndef GEOMETRY_STAGE
  fTexCoord2 = A.TexCoord2;
#else
  gTexCoord2 = A.TexCoord2;  
#endif
}</overload>
        <overload Version="2" Input="inout vrec;" Output="void" Global="varying vec2 fTexCoord2;">{ fTexCoord2 = A.TexCoord2; }</overload>
        <overload Version="34" Input="inout vrec;vec2;" Output="void" Global="#ifndef GEOMETRY_STAGE     
		out vec2 fTexCoord2;     
		#else     
		out vec2 gTexCoord2;     
		#endif">{
#ifndef GEOMETRY_STAGE
  fTexCoord2 = A.TexCoord2*B;
#else
  gTexCoord2 = A.TexCoord2*B;  
#endif
}</overload>
        <overload Version="2" Input="inout vrec;vec2;" Output="void" Global="varying vec2 fTexCoord2;">{ fTexCoord2 = A.TexCoord2*B; }</overload>
      </PassTexCoord2>
      <PassTexCoord3 ObjectType="V">
        <overload Version="34" Input="inout vrec;" Output="void" Global="#ifndef GEOMETRY_STAGE     
		out vec2 fTexCoord3;     
		#else     
		out vec2 gTexCoord3;     
		#endif">{
#ifndef GEOMETRY_STAGE
  fTexCoord3 = A.TexCoord3;
#else
  gTexCoord3 = A.TexCoord3;  
#endif
}</overload>
        <overload Version="2" Input="inout vrec;" Output="void" Global="varying vec2 fTexCoord3;">{ fTexCoord3 = A.TexCoord3; }</overload>
        <overload Version="34" Input="inout vrec;vec2;" Output="void" Global="#ifndef GEOMETRY_STAGE     
		out vec2 fTexCoord3;     
		#else     
		out vec2 gTexCoord3;     
		#endif">{
#ifndef GEOMETRY_STAGE
  fTexCoord3 = A.TexCoord3*B;
#else
  gTexCoord3 = A.TexCoord3*B;  
#endif
}</overload>
        <overload Version="2" Input="inout vrec;vec2;" Output="void" Global="varying vec2 fTexCoord3;">{ fTexCoord3 = A.TexCoord3*B; }</overload>
      </PassTexCoord3>
      <PassTexCoord4 ObjectType="V">
        <overload Version="34" Input="inout vrec;" Output="void" Global="#ifndef GEOMETRY_STAGE     
		out vec2 fTexCoord4;     
		#else     
		out vec2 gTexCoord4;     
		#endif">{
#ifndef GEOMETRY_STAGE
  fTexCoord4 = A.TexCoord4;
#else
  gTexCoord4 = A.TexCoord4;  
#endif
}</overload>
        <overload Version="2" Input="inout vrec;" Output="void" Global="varying vec2 fTexCoord4;">{ fTexCoord4 = A.TexCoord4; }</overload>
        <overload Version="34" Input="inout vrec;vec2;" Output="void" Global="#ifndef GEOMETRY_STAGE     
		out vec2 fTexCoord4;     
		#else     
		out vec2 gTexCoord4;     
		#endif">{
#ifndef GEOMETRY_STAGE
  fTexCoord4 = A.TexCoord4*B;
#else
  gTexCoord4 = A.TexCoord4*B;  
#endif
}</overload>
        <overload Version="2" Input="inout vrec;vec2;" Output="void" Global="varying vec2 fTexCoord4;">{ fTexCoord4 = A.TexCoord4*B; }</overload>
      </PassTexCoord4>
      <PassTexCoord5 ObjectType="V">
        <overload Version="34" Input="inout vrec;" Output="void" Global="#ifndef GEOMETRY_STAGE     
		out vec2 fTexCoord5;     
		#else     
		out vec2 gTexCoord5;     
		#endif">{
#ifndef GEOMETRY_STAGE
  fTexCoord5 = A.TexCoord5;
#else
  gTexCoord5 = A.TexCoord5;  
#endif
}</overload>
        <overload Version="2" Input="inout vrec;" Output="void" Global="varying vec2 fTexCoord5;">{ fTexCoord5 = A.TexCoord5; }</overload>
        <overload Version="34" Input="inout vrec;vec2;" Output="void" Global="#ifndef GEOMETRY_STAGE     
		out vec2 fTexCoord5;     
		#else     
		out vec2 gTexCoord5;     
		#endif">{
#ifndef GEOMETRY_STAGE
  fTexCoord5 = A.TexCoord5*B;
#else
  gTexCoord5 = A.TexCoord5*B;  
#endif
}</overload>
        <overload Version="2" Input="inout vrec;vec2;" Output="void" Global="varying vec2 fTexCoord5;">{ fTexCoord5 = A.TexCoord5*B; }</overload>
      </PassTexCoord5>
      <PassTexCoord6 ObjectType="V">
        <overload Version="34" Input="inout vrec;" Output="void" Global="#ifndef GEOMETRY_STAGE     
		out vec2 fTexCoord6;     
		#else     
		out vec2 gTexCoord6;     
		#endif">{
#ifndef GEOMETRY_STAGE
  fTexCoord6 = A.TexCoord6;
#else
  gTexCoord6 = A.TexCoord6;  
#endif
}</overload>
        <overload Version="2" Input="inout vrec;" Output="void" Global="varying vec2 fTexCoord6;">{ fTexCoord6 = A.TexCoord6; }</overload>
        <overload Version="34" Input="inout vrec;vec2;" Output="void" Global="#ifndef GEOMETRY_STAGE     
		out vec2 fTexCoord6;     
		#else     
		out vec2 gTexCoord6;     
		#endif">{
#ifndef GEOMETRY_STAGE
  fTexCoord6 = A.TexCoord6*B;
#else
  gTexCoord6 = A.TexCoord6*B;  
#endif
}</overload>
        <overload Version="2" Input="inout vrec;vec2;" Output="void" Global="varying vec2 fTexCoord6;">{ fTexCoord6 = A.TexCoord6*B; }</overload>
      </PassTexCoord6>
      <PassTexCoord7 ObjectType="V">
        <overload Version="34" Input="inout vrec;" Output="void" Global="#ifndef GEOMETRY_STAGE     
		out vec2 fTexCoord7;     
		#else     
		out vec2 gTexCoord7;     
		#endif">{
#ifndef GEOMETRY_STAGE
  fTexCoord7 = A.TexCoord7;
#else
  gTexCoord7 = A.TexCoord7;  
#endif
}</overload>
        <overload Version="2" Input="inout vrec;" Output="void" Global="varying vec2 fTexCoord7;">{ fTexCoord7 = A.TexCoord7; }</overload>
        <overload Version="34" Input="inout vrec;vec2;" Output="void" Global="#ifndef GEOMETRY_STAGE     
		out vec2 fTexCoord7;     
		#else     
		out vec2 gTexCoord7;     
		#endif">{
#ifndef GEOMETRY_STAGE
  fTexCoord7 = A.TexCoord7*B;
#else
  gTexCoord7 = A.TexCoord7*B;  
#endif
}</overload>
        <overload Version="2" Input="inout vrec;vec2;" Output="void" Global="varying vec2 fTexCoord7;">{ fTexCoord7 = A.TexCoord7*B; }</overload>
      </PassTexCoord7>
    </Vertex>
    <Geometry>
      <GetTriangle ObjectType="G">
        <overload Version="34" Input="out vrec;out vrec;out vrec;" Output="void" Global="in VertexInput {   vec3 gObjectPosition;   vec3 gObjectNormal;   vec4 gWorldPosition;   vec3 gWorldNormal;   vec4 gVertexColor;   vec3 gCameraVector;   vec4 gScreenPosition;   vec2 gTexCoord0;   vec2 gTexCoord1;   vec2 gTexCoord2;   vec2 gTexCoord3;   vec2 gTexCoord4;   vec2 gTexCoord5;   vec2 gTexCoord6;   vec2 gTexCoord7; } In[3];">{
  A.ObjectPosition = In[0].gObjectPosition;
  A.ObjectNormal = In[0].gObjectNormal;
  A.WorldPosition = In[0].gWorldPosition;
  A.WorldNormal = In[0].gWorldNormal;
  A.VertexColor = In[0].gVertexColor;
  A.CameraVector = In[0].gCameraVector;
  A.ScreenPosition = In[0].gScreenPosition;
  A.TexCoord0 = In[0].gTexCoord0;
  A.TexCoord1 = In[0].gTexCoord1;
  A.TexCoord2 = In[0].gTexCoord2;
  A.TexCoord3 = In[0].gTexCoord3;
  A.TexCoord4 = In[0].gTexCoord4;
  A.TexCoord5 = In[0].gTexCoord5;
  A.TexCoord6 = In[0].gTexCoord6;
  A.TexCoord7 = In[0].gTexCoord7;

  B.ObjectPosition = In[1].gObjectPosition;
  B.ObjectNormal = In[1].gObjectNormal;
  B.WorldPosition = In[1].gWorldPosition;
  B.WorldNormal = In[1].gWorldNormal;
  B.VertexColor = In[1].gVertexColor;
  B.CameraVector = In[1].gCameraVector;
  B.ScreenPosition = In[1].gScreenPosition;
  B.TexCoord0 = In[1].gTexCoord0;
  B.TexCoord1 = In[1].gTexCoord1;
  B.TexCoord2 = In[1].gTexCoord2;
  B.TexCoord3 = In[1].gTexCoord3;
  B.TexCoord4 = In[1].gTexCoord4;
  B.TexCoord5 = In[1].gTexCoord5;
  B.TexCoord6 = In[1].gTexCoord6;
  B.TexCoord7 = In[1].gTexCoord7;

  C.ObjectPosition = In[2].gObjectPosition;
  C.ObjectNormal = In[2].gObjectNormal;
  C.WorldPosition = In[2].gWorldPosition;
  C.WorldNormal = In[2].gWorldNormal;
  C.VertexColor = In[2].gVertexColor;
  C.CameraVector = In[2].gCameraVector;
  C.ScreenPosition = In[2].gScreenPosition;
  C.TexCoord0 = In[2].gTexCoord0;
  C.TexCoord1 = In[2].gTexCoord1;
  C.TexCoord2 = In[2].gTexCoord2;
  C.TexCoord3 = In[2].gTexCoord3;
  C.TexCoord4 = In[2].gTexCoord4;
  C.TexCoord5 = In[2].gTexCoord5;
  C.TexCoord6 = In[2].gTexCoord6;
  C.TexCoord7 = In[2].gTexCoord7;
}</overload>
      </GetTriangle>
      <Shrink ObjectType="G">
        <overload Version="34" Input="in vrec;in vrec;in vrec;float;" Output="void" Uniforms="TShaderEnvViewProjectionMatrix;" Global="uniform mat4 ViewProjectionMatrix;">{
  vec4 Center = (A.WorldPosition + B.WorldPosition + C.WorldPosition) / 3.0;
  vec4 offset;
  offset = (A.WorldPosition - Center)*D + Center;
  A.ScreenPosition = ViewProjectionMatrix * offset; 
  offset = (B.WorldPosition - Center)*D + Center;
  B.ScreenPosition = ViewProjectionMatrix * offset; 
  offset = (C.WorldPosition - Center)*D + Center;
  C.ScreenPosition = ViewProjectionMatrix * offset; 
}</overload>
      </Shrink>
      <EmitTriangle ObjectType="G">
        <overload Version="34" Input="in vrec;in vrec;in vrec;" Output="void" Global="out vec3 fObjectNormal; out vec4 fWorldPosition; out vec3 fWorldNormal; out vec4 fVertexColor; out vec3 fLightVector; out vec3 fCameraVector; out vec2 fTexCoord0; out vec2 fTexCoord1; out vec2 fTexCoord2; out vec2 fTexCoord3; out vec2 fTexCoord4; out vec2 fTexCoord5; out vec2 fTexCoord6; out vec2 fTexCoord7;">{
  gl_Position = A.ScreenPosition;
  fObjectNormal = A.ObjectNormal;
  fWorldPosition = A.WorldPosition;
  fWorldNormal = A.WorldNormal;
  fVertexColor = A.VertexColor;
  fCameraVector = A.CameraVector;
  fTexCoord0 = A.TexCoord0;
  fTexCoord1 = A.TexCoord1;
  fTexCoord2 = A.TexCoord2;
  fTexCoord3 = A.TexCoord3;
  fTexCoord4 = A.TexCoord4;
  fTexCoord5 = A.TexCoord5;
  fTexCoord6 = A.TexCoord6;
  fTexCoord7 = A.TexCoord7;
  EmitVertex();

  gl_Position = B.ScreenPosition;
  fObjectNormal = B.ObjectNormal;
  fWorldPosition = B.WorldPosition;
  fWorldNormal = B.WorldNormal;
  fVertexColor = B.VertexColor;
  fCameraVector = B.CameraVector;
  fTexCoord0 = B.TexCoord0;
  fTexCoord1 = B.TexCoord1;
  fTexCoord2 = B.TexCoord2;
  fTexCoord3 = B.TexCoord3;
  fTexCoord4 = B.TexCoord4;
  fTexCoord5 = B.TexCoord5;
  fTexCoord6 = B.TexCoord6;
  fTexCoord7 = B.TexCoord7;
  EmitVertex();

  gl_Position = C.ScreenPosition;
  fObjectNormal = C.ObjectNormal;
  fWorldPosition = C.WorldPosition;
  fWorldNormal = C.WorldNormal;
  fVertexColor = C.VertexColor;
  fCameraVector = C.CameraVector;
  fTexCoord0 = C.TexCoord0;
  fTexCoord1 = C.TexCoord1;
  fTexCoord2 = C.TexCoord2;
  fTexCoord3 = C.TexCoord3;
  fTexCoord4 = C.TexCoord4;
  fTexCoord5 = C.TexCoord5;
  fTexCoord6 = C.TexCoord6;
  fTexCoord7 = C.TexCoord7;
  EmitVertex();
  EndPrimitive();
}</overload>
      </EmitTriangle>
    </Geometry>
    <Fragment>
      <GetFragment ObjectType="F">
        <overload Version="34" Input="inout frec;" Output="void" Global="in vec4 fWorldPosition; in vec3 fCameraVector;">{
  A.WorldPosition = fWorldPosition;
  A.CameraVector = fCameraVector;
  A.LightIndex = 0;
}</overload>
        <overload Version="2" Input="inout frec;" Output="void" Global="varying vec4 fWorldPosition; varying vec3 fCameraVector;">{
  A.WorldPosition = fWorldPosition;
  A.CameraVector = fCameraVector;
}</overload>
      </GetFragment>
      <AlphaTest ObjectType="F">
        <overload Input="inout frec;float;" Output="void">{ if (A.Opacity&lt;B) discard; }</overload>
      </AlphaTest>
      <SetEmissive ObjectType="F">
        <overload Input="inout frec;" Output="void">{
  A.Emissive = vec3(0.3,0.3,0.3);
}</overload>
        <overload Input="inout frec;float;" Output="void">{
  A.Emissive = vec3(B,0.0,0.0);
}</overload>
        <overload Input="inout frec;vec2;" Output="void">{
  A.Emissive = vec3(B,0.0);
}</overload>
        <overload Input="inout frec;vec3;" Output="void">{
  A.Emissive = B;
}</overload>
        <overload Input="inout frec;vec4;" Output="void">{
  A.Emissive = B.rgb;
}</overload>
      </SetEmissive>
      <SetDiffuse ObjectType="F">
        <overload Input="inout frec;" Output="void">{
  A.Diffuse = vec3(0.5,0.5,0.5);
}</overload>
        <overload Input="inout frec;float;" Output="void">{
  A.Diffuse = vec3(B,0.0,0.0);
}</overload>
        <overload Input="inout frec;vec2;" Output="void">{
  A.Diffuse = vec3(B,0.0);
}</overload>
        <overload Input="inout frec;vec3;" Output="void">{
  A.Diffuse = B;
}</overload>
        <overload Input="inout frec;vec4;" Output="void">{
  A.Diffuse = B.rgb;
}</overload>
      </SetDiffuse>
      <SetSpecular ObjectType="F">
        <overload Input="inout frec;" Output="void">{
  A.Specular = vec3(1.0,1.0,1.0);
}</overload>
        <overload Input="inout frec;float;" Output="void">{
  A.Specular = vec3(B,0.0,0.0);
}</overload>
        <overload Input="inout frec;vec2;" Output="void">{
  A.Specular = vec3(B,0.0);
}</overload>
        <overload Input="inout frec;vec3;" Output="void">{
  A.Specular = B;
}</overload>
        <overload Input="inout frec;vec4;" Output="void">{
  A.Specular = B.rgb;
}</overload>
      </SetSpecular>
      <SetDiffusePower ObjectType="F">
        <overload Input="inout frec;" Output="void">{
  A.DiffusePower = 1.0;
}</overload>
        <overload Input="inout frec;float;" Output="void">{
  A.DiffusePower = B;
}</overload>
        <overload Input="inout frec;vec2;" Output="void">{
  A.DiffusePower = B.r;
}</overload>
        <overload Input="inout frec;vec3;" Output="void">{
  A.DiffusePower = B.r;
}</overload>
        <overload Input="inout frec;vec4;" Output="void">{
  A.DiffusePower = B.r;
}</overload>
      </SetDiffusePower>
      <SetSpecularPower ObjectType="F">
        <overload Input="inout frec;" Output="void">{
  A.SpecularPower = 64.0;
}</overload>
        <overload Input="inout frec;float;" Output="void">{
  A.SpecularPower = B;
}</overload>
        <overload Input="inout frec;vec2;" Output="void">{
  A.SpecularPower = B.r;
}</overload>
        <overload Input="inout frec;vec3;" Output="void">{
  A.SpecularPower = B.r;
}</overload>
        <overload Input="inout frec;vec4;" Output="void">{
  A.SpecularPower = B.r;
}</overload>
      </SetSpecularPower>
      <SetNormal ObjectType="F">
        <overload Input="inout frec;" Output="void" Global="in vec3 fWorldNormal;">{
  A.Normal = fWorldNormal;
}</overload>
        <overload Input="inout frec;float;" Output="void">{
  A.Normal = normalize(vec3(B));
}</overload>
        <overload Input="inout frec;vec2;" Output="void">{
  A.Normal = vec3(B.x,B.y,sqrt(1.0-B.x*B.x-B.y*B.y));
}</overload>
        <overload Input="inout frec;vec3;" Output="void">{
  A.Normal = B;
}</overload>
        <overload Input="inout frec;vec4;" Output="void">{
  A.Normal = B.rgb;
}</overload>
      </SetNormal>
      <SetOpacity ObjectType="F">
        <overload Input="inout frec;" Output="void">{
  A.Opacity = 1.0;
}</overload>
        <overload Input="inout frec;float;" Output="void">{
  A.Opacity = B;
}</overload>
        <overload Input="inout frec;vec2;" Output="void">{
  A.Opacity = B.r;
}</overload>
        <overload Input="inout frec;vec3;" Output="void">{
  A.Opacity = B.r;
}</overload>
        <overload Input="inout frec;vec4;" Output="void">{
  A.Opacity = B.r;
}</overload>
      </SetOpacity>
      <SetOpacityMask ObjectType="F">
        <overload Input="inout frec;" Output="void">{
  A.OpacityMask = 0.5;
}</overload>
        <overload Input="inout frec;float;" Output="void">{
  A.OpacityMask = B;
}</overload>
        <overload Input="inout frec;vec2;" Output="void">{
  A.OpacityMask = B.r;
}</overload>
        <overload Input="inout frec;vec3;" Output="void">{
  A.OpacityMask = B.r;
}</overload>
        <overload Input="inout frec;vec4;" Output="void">{
  A.OpacityMask = B.r;
}</overload>
      </SetOpacityMask>
	  <GetLight ObjectType="F">
	    <overload Version="34" Input="int;" Output="lrec" Uniforms="TShaderEnvLights;" Global="struct lrec {
		vec4 WorldPosition;
		vec3 Ambient; 
		vec3 Diffuse; 
		vec3 Specular; 
		vec3 SpotDirection; 
		float SpotCutoff; 
		float SpotExponent; 
		float ConstantAtten; 
		float LinearAtten; 
		float QuadAtten;
        float SpotCosCutoff;
		};
		
		layout(std140) uniform LightsBlock { lrec Lights[16]; }; 
		uniform int LightIndices[16];">{
  int J = LightIndices[A];
  return Lights[J];  
}</overload>
	  </GetLight>
      <Illuminate ObjectType="F">
        <overload Version="34" Input="inout frec;" Output="void" Uniforms="TShaderEnvLightNumber;" Global="struct lrec {
		vec4 WorldPosition;
		vec3 Ambient; 
		vec3 Diffuse; 
		vec3 Specular; 
		vec3 SpotDirection; 
		float SpotCutoff; 
		float SpotExponent; 
		float ConstantAtten; 
		float LinearAtten; 
		float QuadAtten;
        float SpotCosCutoff;
		};
		
		uniform int LightNumber;
		lrec GetLight(int I);" 
		Local="
		void pointLight(inout frec A, lrec B) {    
		float nDotVP; 		// normal . light direction    
		float nDotHV; 		// normal . light half vector    
		float attenuation;  // computed attenuation factor    
		float d;            // distance from surface to light source    
		vec3  VP;           // direction from surface to light position    
		vec3  halfVector;   // direction of maximum highlights    
		// Compute vector from surface to light position    
		VP = B.WorldPosition.xyz - A.WorldPosition.xyz;    
		// Compute distance between surface and light position    
		d = length(VP);    
		// Normalize the vector from surface to light position    
		VP = normalize(VP);    
		// Compute attenuation    
		attenuation = 1.0 / (B.ConstantAtten + B.LinearAtten * d + B.QuadAtten * d * d);    
		halfVector = normalize(VP + A.CameraVector);    
		nDotVP = pow(max(0.0, dot(A.Normal, VP)), A.DiffusePower);    
		nDotHV = pow(max(0.0, dot(A.Normal, halfVector)), A.SpecularPower);    
		A.LightAmbient  += B.Ambient * attenuation;    
		A.LightDiffuse  += B.Diffuse * nDotVP * attenuation;    
		A.LightSpecular += B.Specular * nDotHV * attenuation; }  
		
		void spotLight(inout frec A, lrec B) {    
		float nDotVP;            // normal . light direction    
		float nDotHV;            // normal . light half vector    
		float spotDot;           // cosine of angle between spotlight    
		float spotAttenuation;   // spotlight attenuation factor 
		float attenuation;       // computed attenuation factor    
		float d;                 // distance from surface to light source    
		vec3  VP;                // direction from surface to light position    
		vec3  halfVector;        // direction of maximum highlights     
		// Compute vector from surface to light position    
		VP = B.WorldPosition.xyz - A.WorldPosition.xyz;     
		// Compute distance between surface and light position    
		d = length(VP);     // Normalize the vector from surface to light position    
		VP = normalize(VP);     // Compute attenuation    
		attenuation = 1.0 / (B.ConstantAtten + B.LinearAtten * d + B.QuadAtten * d * d);     
		// See if point on surface is inside cone of illumination    
		spotDot = dot(-VP, normalize(B.SpotDirection));     
		if (spotDot &lt; B.SpotCosCutoff)    
		{        
		spotAttenuation = 0.0; // light adds no contribution    
		}    
		else    
		{        
		spotAttenuation = pow(spotDot, B.SpotExponent);     
		}    
		// Combine the spotlight and distance attenuation.    
		attenuation *= spotAttenuation;     
		halfVector = normalize(VP + A.CameraVector);     
		nDotVP = pow(max(0.0, dot(A.Normal, VP)), A.DiffusePower);    
		nDotHV = pow(max(0.0, dot(A.Normal, halfVector)), A.SpecularPower);     
		A.LightAmbient  += B.Ambient * attenuation;    
		A.LightDiffuse  += B.Diffuse * nDotVP * attenuation;    
		A.LightSpecular += B.Specular * nDotHV * attenuation; 
		}  
		
		void directionalLight(inout frec A, lrec B) {    
		float nDotVP;         // normal . light direction    
		float nDotHV;         // normal . light half vector    
		vec3 VP;              // direction from surface to light position    
		vec3 halfVector;      // direction of maximum highlights    
		// Compute direction vector of light    
		VP = normalize(B.WorldPosition.xyz);     
		halfVector = normalize(VP + A.CameraVector);     
		nDotVP = pow(max(0.0, dot(A.Normal, VP)), A.DiffusePower);    
		nDotHV = pow(max(0.0, dot(A.Normal, halfVector)), A.SpecularPower);     
		A.LightAmbient += B.Ambient;    
		A.LightDiffuse  += B.Diffuse * nDotVP;    
		A.LightSpecular += B.Specular * nDotHV; }  
		
		void infiniteSpotLight(inout frec A, lrec B) {    
		float nDotVP;         // normal . light direction    
		float nDotHV;         // normal . light half vector    
		vec3 VP;              // direction from surface to light position    
		vec3 halfVector;      // direction of maximum highlights    
		float spotAttenuation;    
		vec3  Ppli;    
		vec3  Sdli;    
		// Compute direction vector of light    
		VP = normalize(B.WorldPosition.xyz);     
		halfVector = normalize(VP + A.CameraVector);     
		nDotVP = pow(max(0.0, dot(A.Normal, VP)), A.DiffusePower);    
		nDotHV = pow(max(0.0, dot(A.Normal, halfVector)), A.SpecularPower);     
		Ppli = -VP;    
		Sdli = B.SpotDirection;     
		spotAttenuation = pow(dot(Ppli, Sdli), B.SpotExponent);     
		A.LightAmbient  += B.Ambient * spotAttenuation;    
		A.LightDiffuse  += B.Diffuse * nDotVP * spotAttenuation;    
		A.LightSpecular += B.Specular * nDotHV * spotAttenuation; }">{
  A.LightAmbient = vec3(0.0);
  A.LightDiffuse = vec3(0.0);
  A.LightSpecular = vec3(0.0);
  for (int I = 0; I &lt; LightNumber &amp;&amp; I &lt; 16; I++)
  {
    lrec LightSource = GetLight(I);
    if (LightSource.WorldPosition.w == 1.0)
    {
      if (LightSource.SpotCosCutoff == -1.0)
      {
         pointLight(A,LightSource);
      }
      else
      {
         spotLight(A,LightSource);
      }
    }
    else
    {
      if (LightSource.SpotCosCutoff == -1.0)
      {
         directionalLight(A,LightSource);
      }
      else
      {
         infiniteSpotLight(A,LightSource);
      }
    }
  }
  A.LightAmbient = clamp(A.LightAmbient,vec3(0.0),vec3(1.0));
  A.LightDiffuse = clamp(A.LightDiffuse,vec3(0.0),vec3(1.0));
  A.LightSpecular = clamp(A.LightSpecular,vec3(0.0),vec3(1.0));
  vec3 finalColor = A.Emissive + A.LightAmbient;
  finalColor += A.Diffuse * A.LightDiffuse;
  finalColor += A.Specular * A.LightSpecular;
  A.Emissive = finalColor; }
        </overload>
      </Illuminate>
	  <SetCustomLighting ObjectType="F">
        <overload Input="inout frec;float;" Output="void" Uniforms="TShaderEnvLights;" Global="uniform int LightNumber;"
        Pre="for (int I = 0; I &lt; LightNumber &amp;&amp; I &lt; 16; I++) {
		Local0.LightIndex = I" Post="}">{ A.Emissive += vec3(B,0.0,0.0); }</overload>	  
        <overload Input="inout frec;vec2;" Output="void" Uniforms="TShaderEnvLights;" Global="uniform int LightNumber;"
        Pre="for (int I = 0; I &lt; LightNumber &amp;&amp; I &lt; 16; I++) {
		Local0.LightIndex = I" Post="}">{ A.Emissive += vec3(B,0.0); }</overload>	  
        <overload Input="inout frec;vec3;" Output="void" Uniforms="TShaderEnvLights;" Global="uniform int LightNumber;"
        Pre="for (int I = 0; I &lt; LightNumber &amp;&amp; I &lt; 16; I++) {
		Local0.LightIndex = I" Post="}">{ A.Emissive += B; }</overload>
        <overload Input="inout frec;vec4;" Output="void" Uniforms="TShaderEnvLights;" Global="uniform int LightNumber;"
        Pre="for (int I = 0; I &lt; LightNumber &amp;&amp; I &lt; 16; I++) {
		Local0.LightIndex = I" Post="}">{ A.Emissive += B.rgb; }</overload>		
	  </SetCustomLighting>
      <PassFragmentColor ObjectType="F">
        <overload Version="34" Input="inout frec;" Output="void" Global="out vec4 FragColor;">{ FragColor = vec4(A.Emissive, A.Opacity); }</overload>
        <overload Version="2" Input="inout frec;" Output="void">{ gl_FragColor = vec4(A.Emissive, A.Opacity); }</overload>
      </PassFragmentColor>
    </Fragment>
    <!--V2F - vertex program to fragment program
V2G - vertex program to geometry program

O2W - object space to world space
W2S - world space to screen space
W2T - world space to texture space

-->
  </Samples>
</TGL3xMaterial>